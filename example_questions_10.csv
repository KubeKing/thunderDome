Question,Model Answer,Student Answer,Model Grade
"In object-oriented programming, what is the difference between method overloading and method overriding?","Method overloading allows multiple methods in the same class to have the same name but different parameters, enabling compile-time polymorphism. Method overriding allows a subclass to provide a specific implementation for a method already defined in its superclass, enabling runtime polymorphism.",Method overloading is when two methods have the same name but different parameters. Method overriding is when a subclass has a method with the same name and parameters as a method in its superclass but with a different implementation.,0.9
"Explain the difference between a stack and a queue data structure.","A stack is a Last-In-First-Out (LIFO) data structure where elements are added and removed from the same end, typically called the top. A queue is a First-In-First-Out (FIFO) data structure where elements are added at one end (rear) and removed from the other end (front).",A stack uses LIFO (Last In First Out) where you can only remove the most recently added item. A queue uses FIFO (First In First Out) where items are removed in the order they were added.,0.8
"What is the time complexity of binary search and how does it work?","Binary search has a time complexity of O(log n). It works by repeatedly dividing the search interval in half. It begins with the entire sorted array, compares the middle element with the target value, and eliminates half of the remaining elements based on the comparison.","Binary search is O(log n) and works by checking the middle element of a sorted array, then discarding half the array based on if the target is greater or less than the middle value, until the element is found.",0.9
"What is a primary key in a relational database?",A primary key is a column or set of columns in a table that uniquely identifies each row in that table. It must contain unique values and cannot contain NULL values. Primary keys enforce entity integrity and are used to establish relationships between tables.,"A primary key is a unique identifier for each record in a database table. No two rows can have the same primary key value, and it can't be null.",0.7
"What is the significance of the 'virtual' keyword in C++?","The 'virtual' keyword in C++ is used to declare a method that can be overridden in a derived class. When a method is declared as virtual, the compiler determines which method implementation to call at runtime based on the actual object type rather than the reference type, enabling runtime polymorphism.","Virtual in C++ means that a function can be overridden by derived classes, allowing for runtime polymorphism. Without virtual, the function to be called is determined at compile-time.",0.8
"What is the difference between a breadth-first search (BFS) and a depth-first search (DFS) algorithm?","Breadth-first search (BFS) and depth-first search (DFS) are graph traversal algorithms that differ in their exploration strategy. BFS explores all neighbors at the current depth level before moving to nodes at the next depth level, typically implemented using a queue data structure. This makes BFS optimal for finding the shortest path in unweighted graphs. DFS, on the other hand, explores as far as possible along each branch before backtracking, typically implemented using a stack or recursion. DFS is often more memory-efficient but doesn't guarantee the shortest path. Both algorithms have a time complexity of O(V+E) where V is the number of vertices and E is the number of edges.",BFS uses a queue and explores all neighbors of a node before moving to the next level. DFS uses a stack or recursion and goes as deep as possible before backtracking. BFS is good for shortest paths in unweighted graphs while DFS is more memory efficient for deep graphs.,0.85
"Explain the concept of hashing and describe how hash collisions are typically resolved.","Hashing is a technique that maps data of arbitrary size to fixed-size values (hash codes) using a hash function. It allows for efficient data retrieval in hash tables with average O(1) time complexity. Hash collisions occur when two different inputs produce the same hash code. Common collision resolution techniques include: (1) Chaining, where each bucket contains a linked list of all elements that hash to the same index; (2) Open addressing, where if a collision occurs, alternative positions are tried using methods like linear probing (checking the next slot), quadratic probing (using quadratic function to determine next slots), or double hashing (using a second hash function); (3) Robin Hood hashing, which minimizes the variance of probe sequence lengths. Each method has different trade-offs regarding memory usage, performance, and implementation complexity.","Hashing converts data into a fixed-size value using a hash function to enable O(1) lookups in a hash table. When two inputs produce the same hash value (collision), we need collision resolution strategies. The main ones are chaining (keeping a linked list at each bucket) and open addressing (finding another empty slot in the table using techniques like linear probing or double hashing).",0.9
"What is the CAP theorem in distributed systems and why is it important?","The CAP theorem, formulated by Eric Brewer, states that a distributed data store cannot simultaneously provide more than two out of three guarantees: Consistency (all nodes see the same data at the same time), Availability (every request receives a response, without guarantee that it contains the most recent data), and Partition tolerance (the system continues to function despite network partitions). Since network partitions are unavoidable in distributed systems, designers must choose between consistency and availability when partitions occur. The theorem is important because it guides architectural decisions in distributed systems based on specific requirements. For instance, traditional RDBMS systems like PostgreSQL prioritize consistency over availability, while NoSQL databases like Cassandra might prioritize availability over strict consistency, offering eventual consistency instead.","The CAP theorem says you can only have 2 out of 3 properties in a distributed system: Consistency, Availability, and Partition tolerance. Since network partitions will happen, you really have to choose between consistency and availability. Traditional databases choose consistency while many NoSQL systems choose availability with eventual consistency.",0.8
"Explain the concept of dynamic programming and provide an example of a problem where it would be applicable.","Dynamic programming is an algorithmic technique for solving complex problems by breaking them down into simpler overlapping subproblems and storing the results to avoid redundant calculations. It applies two key concepts: optimal substructure (an optimal solution contains optimal solutions to subproblems) and overlapping subproblems (same subproblems are solved multiple times). The Fibonacci sequence calculation is a classic example where dynamic programming significantly improves efficiency. Without memoization, a recursive Fibonacci implementation has exponential time complexity O(2^n). With dynamic programming, using either top-down memoization or bottom-up tabulation, the time complexity improves to O(n). Other common examples include the knapsack problem, longest common subsequence, matrix chain multiplication, and shortest path algorithms like Floyd-Warshall.","Dynamic programming solves problems by breaking them into smaller subproblems, solving each once, and storing the results to avoid recalculating them later. It works for problems with overlapping subproblems and optimal substructure. A good example is finding the nth Fibonacci number: instead of using recursion which recalculates the same values many times, we can store each Fibonacci number as we calculate it and reuse it, reducing time complexity from O(2^n) to O(n).",0.95
"What is the difference between process and thread in operating systems?","A process is an independent program in execution with its own memory space, system resources, and process control block (PCB). Each process has at least one thread (the main thread) and is isolated from other processes, requiring inter-process communication (IPC) mechanisms for data sharing. A thread, in contrast, is a lightweight execution unit within a process that shares the process's memory space and resources with other threads in the same process. Threads have their own program counter, stack, and registers but share code, data, and files with other threads in the process. Thread creation and context switching are less resource-intensive than process operations. The key differences include: memory isolation (processes have separate memory spaces while threads share memory), resource allocation (processes have independent resources while threads share most resources), communication (processes require IPC while threads can directly access shared memory), and overhead (processes have higher creation and context-switching overhead than threads).","A process is an instance of a program being executed with its own memory space and resources. A thread is a smaller unit of execution within a process that shares the process's resources. Processes are isolated from each other and need special mechanisms like pipes or sockets to communicate, while threads share memory and can communicate directly. Processes have more overhead for creation and context switching compared to threads. Each process has at least one thread, and multiple threads in the same process share code, data, and files but have their own stack and registers.",0.92